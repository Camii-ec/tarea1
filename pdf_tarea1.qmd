---
title: "Tarea 1"
subtitle: "EYP3907 - Series de Tiempo"
format: 
  pdf: 
    include-in-header: 
      text: |
        \usepackage{amsmath}
    colorlinks: true
    geometry:
      - top=20mm
      - left=20mm
      - right=20mm
      - heightrounded
    fig-pos: H
author: 
  - name: "Sebastián Celaya"
  - name: "Camila Echeverría"
  - name: "Francisca Vilca"
crossref:
  fig-title: Figura
  fig-prefix: Figura
  tbl-title: Tabla
  tbl-prefix: Tabla
tbl-cap-location: bottom
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = F, warning = F)

# Paquetes
library(tidyverse)
library(dplyr)
library(lubridate) # por el año
library(patchwork)
# library(kableExtra)
# Analisis de la serie de tiempo
library(lmtest)
library(forecast)

## Funciones 
source("TS.diag.R")
source("summary.arima.R")
source("salida.arima.R")

# Carga de datos
data <- rio::import("datos_970410_231003.csv")

df <- janitor::clean_names(data)
```


## Introducción 

En esta tarea, utilizaremos los datos mensuales de concentración de monóxido de carbono (CO), recopilados en la estación de monitores de Pudahuel, para ajustar un modelo de regresión que nos permita predecir la concentración de este contaminante a lo largo del tiempo. 


```{r echo=FALSE}
# Ponemos el formato de las fechas
df$fecha_yymmdd = as.Date(
  # para los que son 00 0X 01
  ifelse(df$fecha_yymmdd < 1000, 
         paste0("000", df$fecha_yymmdd),
         # para los 3 que son 00 1X 01
         ifelse(df$fecha_yymmdd < 2000, 
                paste0("00", df$fecha_yymmdd),
                # Para los que son 0X XX 01
                ifelse(df$fecha_yymmdd < 100000, 
                       paste0("0", df$fecha_yymmdd),
                       as.character(df$fecha_yymmdd)))),
  format = "%y%m%d"
)

# Analizaremos el monoxido de carbono
df$co <- ifelse(
  df$registros_validados != "",
  # Primero los registros válidos
  df$registros_validados,
  ifelse(
    !is.na(df$registros_preliminares),
    # Segundo los registros preliminares
    df$registros_preliminares,
    # Tercero los registros no válidos
    df$registros_no_validados
  )
)

# Declaramos de donde vienen los datos
# por qué? pues porque si
df$tipo_registro = ifelse(
  df$registros_validados != "",
  # Primero los registros válidos
  "Registro válido",
  ifelse(
    !is.na(df$registros_preliminares),
    # Segundo los registros preliminares
    "Registro preliminar",
    # Tercero los registros no válidos
    "Registro no válido"
  )
)

# Declaramos los datos que usaremos en la construcción del modelo
# y los datos que se ocuparán en la validación
df$uso =ifelse(df$fecha_yymmdd < as.Date("2022-12-31"),
               "Entrenamiento",
               "Validación")

df$co <- as.numeric(gsub(",", ".", df$co))
train <- df %>% 
  filter(uso == "Entrenamiento")

Xt <- na.omit(train$co)
Xt <- ts(Xt, start = c(1997,5), frequency = 12)
t <- as.numeric(time(Xt))
```


## Análisis Exploratorio

Los niveles de Monóxido de Carbono registrados en Pudahuel presentan los siguientes valores:

```{r, fig.width = 10, fig.height = 3}
# Graficos de series de tiempo
time_serie = train %>% 
  ggplot(aes(x = fecha_yymmdd, y = co)) +
  geom_line(color = "#808080", size = 0.8) +  
  labs(title = "Variación del Monóxido de Carbono en ppm en Estación Pudahuel",
       subtitle = "Registros válidos desde mayo de 1997 a diciembre del 2022",
       caption = "Datos otorgados por Ministerio del Medio Ambiente de Chile",
       x = "Fecha", y = "Valor") +
  scale_x_date(date_breaks = "2 year", date_labels = "%Y") +
  theme_bw() +
  theme(plot.title = element_text(size = 10,
                                  #face = "bold",
                                  color = "black",
                                  hjust = 0.5),
        plot.subtitle = element_text(size = 9,
                                     #face = "bold",
                                     color = "black",
                                     hjust = 0.5),
        axis.text.x = element_text(angle = 45, hjust = 1))


# Boxplot de los datos  Esta bonito, a ponerlo
box_plot = df %>%
  ggplot(aes(x = co, y = 0)) +
  # geom_violin(color = "purple3") +
  geom_boxplot(fill = "#808080",
               width = 0.3) +
  ylim(c(-0.5, 0.5)) +
  theme_bw() +
  xlab("CO ppm") +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.y = element_blank(),
        plot.title = element_text(size = 10,
                                  #face = "bold",
                                  color = "black",
                                  hjust = 0.5),
        plot.subtitle = element_text(size = 9,
                                     #face = "bold",
                                     color = "black",
                                     hjust = 0.5),
        axis.title.x = element_text(size = 8)) +
  labs(title = "Boxplot de Monóxido de Carbono",
       subtitle = "Medida en Pudahuel")

time_serie | box_plot
```

Del gráfico anterior se puede se puede ver que los niveles de Monóxido de Carbono se concentran principalmente se concentran en valores cercanos a $0.5$, igualmente se observa con una gran varianza. a modo de resumen se puede presentar la tabla de abajo, resumiendo los valores del gráfico anterior.

\begin{table}[ht]
\centering
\begin{tabular}{| c | c | c | c | c | c | c |}
\toprule
Mínimo & 1° Cuartil & Mediana & Promedio & 3° Cuartil & Máximo & Valores NA \\
\midrule
0.1305 & 0.3318 & 0.5716 & 0.8599 & 1.2484 & 3.4134 & 3 \\
\bottomrule
\end{tabular}
\caption{Tabla con Cuartiles}
\label{tab:cuartiles}
\end{table}

## Ajuste del modelo

### Ajuste modelo *lineal y no lineal*

### Ajuste con función `auto.arima()`

Si se realiza el ajuste de la serie de tiempo usando la función `auto.arima()` de la librería `forecast`. Esta recomienda usar un modelo AR(1) en los datos y de los resultados del ajuste, es posible dar razones de porque es recomendable usar este modelo:

- Los residuos son homocedasticos, esto es sencillo de notar, ya que, el test de Breusch-Pagan no se rechaza a un nivel de confianza al $5\%$, por lo que se permite afirmar que los residuos son de varianza constante.

- No hay autocorrelación en los residuos: Como el ínteres es que no existan patrones en los residuos, es bastante bueno que el modelo AR(1) que recomienda la función `auto.arima()`, demuestre que no pasa:

```{r echo = FALSE}
train <- df %>% 
  filter(uso == "Entrenamiento")

Xt <- na.omit(train$co)
Xt <- ts(Xt, start = c(1997,5), frequency = 12)
t <- as.numeric(time(Xt))
lambda <- forecast::BoxCox.lambda(Xt, method = "guerrero")
fit <- forecast::auto.arima(Xt, lambda = lambda)

# ACF
acf_residuals <- acf(fit$residuals, plot = FALSE)
acf_data <- data.frame(Lag = acf_residuals$lag, ACF = acf_residuals$acf)

# PACF
pacf_residuals <- pacf(fit$residuals, plot = FALSE)
pacf_data <- data.frame(Lag = pacf_residuals$lag, PACF = pacf_residuals$acf)

n = nrow(acf_data)
```

```{r, fig.width = 10, fig.height = 3}
acf = ggplot(acf_data, aes(x = Lag, y = ACF)) +
  geom_hline(yintercept = 0,
             linetype = "dashed") + 
  geom_hline(yintercept = 1.96/sqrt(n),
             linetype = "dashed",
             col = "blue") + 
  geom_hline(yintercept = -1.96/sqrt(n),
             linetype = "dashed",
             col = "blue") + 
  geom_segment(aes(xend = Lag,
                   yend = 0),
               color = "purple",
               size = 1) + # Líneas verticales
  geom_point(size = 2.5,
             shape = 21,
             fill = "purple") + # Puntos de color en el extremo de las líneas
  labs(x = "Lag",
       y = "ACF",
       title = "Gráfico de Autocorrelación para los residuos del modelo AR(1)") +
  theme_bw() +
  theme(axis.text.y = element_text(size = 8),
        # axis.ticks.y = element_blank(),
        axis.title.y = element_text(size = 8),
        plot.title = element_text(size = 10,
                                  face = "bold", # Titulo en negrita
                                  color = "black",
                                  hjust = 0.5),
        axis.title.x = element_text(size = 8),
        axis.text.x = element_text(size = 8))

pacf = pacf_data %>%
  ggplot(aes(x = Lag, y = PACF)) +
  geom_hline(yintercept = 0,
             linetype = "dashed") + 
  geom_hline(yintercept = 1.96/sqrt(n),
             linetype = "dashed",
             col = "blue") + 
  geom_hline(yintercept = -1.96/sqrt(n),
             linetype = "dashed",
             col = "blue") + 
  geom_segment(aes(xend = Lag,
                   yend = 0),
               color = "purple",
               size = 1) + # Líneas verticales
  geom_point(size = 2.5,
             shape = 21,
             fill = "purple") + # Puntos de color en el extremo de las líneas
  labs(x = "Lag",
       y = "ACF",
       title = "Gráfico de Autocorrelación Parcial para los residuos del modelo AR(1)") +
  theme_bw() +
  theme(axis.text.y = element_text(size = 8),
        # axis.ticks.y = element_blank(),
        axis.title.y = element_text(size = 8),
        plot.title = element_text(size = 10,
                                  face = "bold", # Titulo en negrita
                                  color = "black",
                                  hjust = 0.5),
        axis.title.x = element_text(size = 8),
        axis.text.x = element_text(size = 8))

(acf | pacf)
```
