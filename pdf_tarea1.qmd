---
title: "Tarea 1"
subtitle: "EYP3907 - Series de Tiempo"
format: 
  pdf: 
    include-in-header: 
      text: |
        \usepackage{amsmath}
    colorlinks: true
    geometry:
      - top=20mm
      - left=20mm
      - right=20mm
      - heightrounded
    fig-pos: H
author: 
  - name: "Sebastián Celaya"
  - name: "Camila Echeverría"
  - name: "Francisca Vilca"
crossref:
  fig-title: Figura
  fig-prefix: Figura
  tbl-title: Tabla
  tbl-prefix: Tabla
tbl-cap-location: bottom
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = F, warning = F)

# Paquetes
library(tidyverse)
library(dplyr)
library(lubridate) # por el año
library(patchwork)
# library(kableExtra)
# Analisis de la serie de tiempo
library(lmtest)
library(forecast)

## Funciones 
source("TS.diag.R")
source("summary.arima.R")
source("salida.arima.R")

# Carga de datos
data <- rio::import("datos_970410_231003.csv")

df <- janitor::clean_names(data)
```


## Introducción 

En esta tarea, utilizaremos los datos mensuales de concentración de monóxido de carbono (CO), recopilados en la estación de monitores de Pudahuel, para ajustar un modelo de regresión que nos permita predecir la concentración de este contaminante a lo largo del tiempo. 


```{r echo=FALSE}
# Ponemos el formato de las fechas
df$fecha_yymmdd = as.Date(
  # para los que son 00 0X 01
  ifelse(df$fecha_yymmdd < 1000, 
         paste0("000", df$fecha_yymmdd),
         # para los 3 que son 00 1X 01
         ifelse(df$fecha_yymmdd < 2000, 
                paste0("00", df$fecha_yymmdd),
                # Para los que son 0X XX 01
                ifelse(df$fecha_yymmdd < 100000, 
                       paste0("0", df$fecha_yymmdd),
                       as.character(df$fecha_yymmdd)))),
  format = "%y%m%d"
)

# Analizaremos el monoxido de carbono
df$co <- ifelse(
  df$registros_validados != "",
  # Primero los registros válidos
  df$registros_validados,
  ifelse(
    !is.na(df$registros_preliminares),
    # Segundo los registros preliminares
    df$registros_preliminares,
    # Tercero los registros no válidos
    df$registros_no_validados
  )
)

# Declaramos de donde vienen los datos
# por qué? pues porque si
df$tipo_registro = ifelse(
  df$registros_validados != "",
  # Primero los registros válidos
  "Registro válido",
  ifelse(
    !is.na(df$registros_preliminares),
    # Segundo los registros preliminares
    "Registro preliminar",
    # Tercero los registros no válidos
    "Registro no válido"
  )
)

# Declaramos los datos que usaremos en la construcción del modelo
# y los datos que se ocuparán en la validación
df$uso =ifelse(df$fecha_yymmdd < as.Date("2022-12-31"),
               "Entrenamiento",
               "Validación")

df$co <- as.numeric(gsub(",", ".", df$co))
train <- df %>% 
  filter(uso == "Entrenamiento")

Xt <- na.omit(train$co)
Xt <- ts(Xt, start = c(1997,5), frequency = 12)
t <- as.numeric(time(Xt))
```


## Análisis Exploratorio

Los niveles de Monóxido de Carbono (CO) registrados en Pudahuel presentan los siguientes valores:

```{r, fig.width = 10, fig.height = 3}
# Graficos de series de tiempo
time_serie = train %>% 
  ggplot(aes(x = fecha_yymmdd, y = co)) +
  geom_line(color = "#808080", size = 0.8) +  
  labs(title = "Variación del Monóxido de Carbono en ppm en Estación Pudahuel",
       subtitle = "Registros válidos desde mayo de 1997 a diciembre del 2022",
       caption = "Datos otorgados por Ministerio del Medio Ambiente de Chile",
       x = "Fecha", y = "Valor") +
  scale_x_date(date_breaks = "2 year", date_labels = "%Y") +
  theme_bw() +
  theme(plot.title = element_text(size = 10,
                                  #face = "bold",
                                  color = "black",
                                  hjust = 0.5),
        plot.subtitle = element_text(size = 9,
                                     #face = "bold",
                                     color = "black",
                                     hjust = 0.5),
        axis.text.x = element_text(angle = 45, hjust = 1))


# Boxplot de los datos  Esta bonito, a ponerlo
box_plot = df %>%
  ggplot(aes(x = co, y = 0)) +
  # geom_violin(color = "purple3") +
  geom_boxplot(fill = "#808080",
               width = 0.3) +
  ylim(c(-0.5, 0.5)) +
  theme_bw() +
  xlab("CO ppm") +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.y = element_blank(),
        plot.title = element_text(size = 10,
                                  #face = "bold",
                                  color = "black",
                                  hjust = 0.5),
        plot.subtitle = element_text(size = 9,
                                     #face = "bold",
                                     color = "black",
                                     hjust = 0.5),
        axis.title.x = element_text(size = 8)) +
  labs(title = "Boxplot de Monóxido de Carbono",
       subtitle = "Medida en Pudahuel")

time_serie | box_plot
```

Del gráfico anterior se puede ver que los niveles de CO son valores cercanos a $0.5$, igualmente se observa que hay una gran varianza. A modo de resumen, se ven los valores del gráfico anterior en la Tabla 1.

\begin{table}[ht]
\centering
\begin{tabular}{| c | c | c | c | c | c | c |}
\toprule
Mínimo & 1° Cuartil & Mediana & Promedio & 3° Cuartil & Máximo & Valores NA \\
\midrule
0.1305 & 0.3318 & 0.5716 & 0.8599 & 1.2484 & 3.4134 & 2  \\
\bottomrule
\end{tabular}
\caption{Tabla con Cuartiles}
\label{tab:cuartiles}
\end{table}

Los datos temporales anteriormente presentados presentan los siguientes gráficos de autocorrelación y de autocorrelación parcial:

```{r}
# ACF base
acf <- acf(Xt, plot = FALSE)
acf_data <- data.frame(Lag = acf$lag,
                       ACF = acf$acf)

# PACF base
pacf <- pacf(Xt, plot = FALSE)
pacf_data <- data.frame(Lag = pacf$lag,
                        PACF = pacf$acf)

n = nrow(df)
```

```{r, fig.width = 10, fig.height = 3}
ACF = ggplot(acf_data, aes(x = Lag, y = ACF)) +
  geom_hline(yintercept = 0,
             linetype = "dashed") + 
  geom_hline(yintercept = 1.96/sqrt(n),
             linetype = "dashed",
             col = "blue") + 
  geom_hline(yintercept = -1.96/sqrt(n),
             linetype = "dashed",
             col = "blue") + 
  geom_segment(aes(xend = Lag,
                   yend = 0),
               color = "purple",
               size = 1) + # Líneas verticales
  geom_point(size = 2.5,
             shape = 21,
             fill = "purple") + # Puntos de color en el extremo de las líneas
  labs(x = "Lag",
       y = "ACF",
       title = "Gráfico de Autocorrelación de los datos") +
  theme_bw() +
  theme(axis.text.y = element_text(size = 8),
        # axis.ticks.y = element_blank(),
        axis.title.y = element_text(size = 8),
        plot.title = element_text(size = 10,
                                  #face = "bold",
                                  color = "black",
                                  hjust = 0.5),
        axis.title.x = element_text(size = 8),
        axis.text.x = element_text(size = 8))

PACF = pacf_data %>%
  ggplot(aes(x = Lag, y = PACF)) +
  geom_hline(yintercept = 0,
             linetype = "dashed") + 
  geom_hline(yintercept = 1.96/sqrt(n),
             linetype = "dashed",
             col = "blue") + 
  geom_hline(yintercept = -1.96/sqrt(n),
             linetype = "dashed",
             col = "blue") + 
  geom_segment(aes(xend = Lag,
                   yend = 0),
               color = "purple",
               size = 1) + # Líneas verticales
  geom_point(size = 2.5,
             shape = 21,
             fill = "purple") + # Puntos de color en el extremo de las líneas
  labs(x = "Lag",
       y = "ACF",
       title = "Gráfico de Autocorrelación Parcial de los datos") +
  theme_bw() +
  theme(axis.text.y = element_text(size = 8),
        # axis.ticks.y = element_blank(),
        axis.title.y = element_text(size = 8),
        plot.title = element_text(size = 10,
                                  #face = "bold",
                                  color = "black",
                                  hjust = 0.5),
        axis.title.x = element_text(size = 8),
        axis.text.x = element_text(size = 8))

(ACF | PACF)
```


## Ajuste del modelo

Como se pudo ver en el gráfico de autocorrelación, presentamos estacionalidad en los datos. Es por esto que utilizaremos la transformación de box-cox en ambos ajustes.

### Ajuste modelo de regresión lineal con dummies

```{r}
#| echo: false
#| results: hide

junio <- na.omit(subset(df, format(fecha_yymmdd, "%m") == "06")$co)
julio <- na.omit(subset(df, format(fecha_yymmdd, "%m") == "07")$co)


df_train <- df %>%
  filter(uso == "Entrenamiento") %>% 
  select(-uso) 

df_train <- df_train[df_train$fecha_yymmdd >= as.Date("1997-12-31"),]

xt_train <- ts(df_train$co, start = c(1998, 1), frequency = 12)
xt_train[is.na(xt_train)] <- c(mean(junio), mean(julio))

t_train <- c(time(xt_train))


df_test <- df %>% 
  filter(uso == "Validación") %>% 
  select(-uso) 

xt_test <- ts(df_test$co, start = c(2023, 1), end = c(2023, 9), frequency = 12)

t_test <- c(time(xt_test))

D <- rep(1:12, 25)

train <- data.frame(x = xt_train, t = t_train, D = as.factor(D))
test <- data.frame(x = xt_test, t = t_test, D = as.factor(1:9))

mod <- lm(x ~ t*(D), data = train)
a <- MASS::boxcox(mod, plotit = FALSE)
lambda <- a$x[which.max(a$y)]

xt_train2.0 <- (xt_train^lambda - 1)/lambda
xt_test2.0 <- (xt_test^lambda - 1)/lambda

train2.0 <- data.frame(x = xt_train2.0, t = t_train, D = as.factor(D))
test2.0 <- data.frame(x = xt_test2.0, t = t_test, D = as.factor(1:9))

mod <- lm(x ~ t*(D), data = train2.0) # Interacciones significativas

pred <- forecast(mod, newdata = test2.0)
pred_box <- (pred$mean*lambda+1)^(1/lambda)
```


Al tener un período de estacionalidad igual a 12, ajustaremos un modelo regresión lineal con 12 variables dummies. Consideramos, además, la transformación de box-cox utilizando $\lambda=0.22$ para este modelo. Así, podemos obtener las siguientes conclusiones:

- Con un valor-p de 0.01, el modelo rechaza los test de normalidad.

- Por otro lado, con un valor-p de 0.12, el test de Breusch-Pagan no rechaza la homocedasticidad, por lo que podemos concluir que el modelo presenta residuos con varianza constante.

Luego, vemos los gráficos de autocorrelación y autocorrelación parcial de los residuos:

```{r fig.width = 10, fig.height = 3}
#| echo: false
#| results: hide

acf_res <- acf(mod$residuals, plot = FALSE)
acf_data1 <- data.frame(Lag = acf_res$lag, ACF = acf_res$acf)



pacf_res <- pacf(mod$residuals, plot = FALSE)
pacf_data1 <- data.frame(Lag = pacf_res$lag, PACF = pacf_res$acf)

n = length(xt_train)

acf1 = ggplot(acf_data1, aes(x = Lag, y = ACF)) +
  geom_hline(yintercept = 0,
             linetype = "dashed") + 
  geom_hline(yintercept = 1.96/sqrt(n),
             linetype = "dashed",
             col = "blue") + 
  geom_hline(yintercept = -1.96/sqrt(n),
             linetype = "dashed",
             col = "blue") + 
  geom_segment(aes(xend = Lag,
                   yend = 0),
               color = "purple",
               size = 1) + # Líneas verticales
  geom_point(size = 2.5,
             shape = 21,
             fill = "purple") + # Puntos de color en el extremo de las líneas
  labs(x = "Lag",
       y = "ACF",
       title = "Gráfico de Autocorrelación para los residuos del modelo de regresión lineal") +
  theme_bw() +
  theme(axis.text.y = element_text(size = 8),
        # axis.ticks.y = element_blank(),
        axis.title.y = element_text(size = 8),
        plot.title = element_text(size = 10,
                                  face = "bold", # Titulo en negrita
                                  color = "black",
                                  hjust = 0.5),
        axis.title.x = element_text(size = 8),
        axis.text.x = element_text(size = 8))

pacf1 = pacf_data1 %>%
  ggplot(aes(x = Lag, y = PACF)) +
  geom_hline(yintercept = 0,
             linetype = "dashed") + 
  geom_hline(yintercept = 1.96/sqrt(n),
             linetype = "dashed",
             col = "blue") + 
  geom_hline(yintercept = -1.96/sqrt(n),
             linetype = "dashed",
             col = "blue") + 
  geom_segment(aes(xend = Lag,
                   yend = 0),
               color = "purple",
               size = 1) + # Líneas verticales
  geom_point(size = 2.5,
             shape = 21,
             fill = "purple") + # Puntos de color en el extremo de las líneas
  labs(x = "Lag",
       y = "PACF",
       title = "Gráfico de Autocorrelación Parcial para los residuos del modelo de regresión lineal") +
  theme_bw() +
  theme(axis.text.y = element_text(size = 8),
        # axis.ticks.y = element_blank(),
        axis.title.y = element_text(size = 8),
        plot.title = element_text(size = 10,
                                  face = "bold", # Titulo en negrita
                                  color = "black",
                                  hjust = 0.5),
        axis.title.x = element_text(size = 8),
        axis.text.x = element_text(size = 8))+
  scale_y_continuous(limits = c(-0.8,0.8))

(acf1 | pacf1)
```

De esta manera, se puede apreciar que el modelo que sugiere esta estructura de correlación corresponde a un ARMA(2,4).

### Ajuste con función `auto.arima()`

CAMBIAR LOS VALORES CON LOS DATOS DE ESTA WEÁ

Si se realiza el ajuste de la serie de tiempo usando la función `auto.arima()` de la librería `forecast`. Esta recomienda usar un modelo AR(1) en los datos y de los resultados del ajuste, es posible dar razones de porque es recomendable usar este modelo:

- Los residuos son homocedásticos, esto es sencillo de notar, ya que, el test de Breusch-Pagan no se rechaza a un nivel de confianza al $5\%$, por lo que se permite afirmar que los residuos son de varianza constante.

- No hay autocorrelación en los residuos: Como el ínteres es que no existan patrones en los residuos, es bastante bueno que el modelo AR(1) que recomienda la función `auto.arima()`, demuestre que no pasa:

```{r echo = FALSE}
train <- df %>% 
  filter(uso == "Entrenamiento")

Xt <- na.omit(train$co)
Xt <- ts(Xt, start = c(1997,5), frequency = 12)
t <- as.numeric(time(Xt))
lambda <- forecast::BoxCox.lambda(Xt, method = "guerrero")
fit <- forecast::auto.arima(Xt, lambda = lambda)

# ACF
acf_residuals <- acf(fit$residuals, plot = FALSE)
acf_data <- data.frame(Lag = acf_residuals$lag, ACF = acf_residuals$acf)

# PACF
pacf_residuals <- pacf(fit$residuals, plot = FALSE)
pacf_data <- data.frame(Lag = pacf_residuals$lag, PACF = pacf_residuals$acf)

n = length(xt_train)
```

```{r, fig.width = 10, fig.height = 3}
acf = ggplot(acf_data, aes(x = Lag, y = ACF)) +
  geom_hline(yintercept = 0,
             linetype = "dashed") + 
  geom_hline(yintercept = 1.96/sqrt(n),
             linetype = "dashed",
             col = "blue") + 
  geom_hline(yintercept = -1.96/sqrt(n),
             linetype = "dashed",
             col = "blue") + 
  geom_segment(aes(xend = Lag,
                   yend = 0),
               color = "purple",
               size = 1) + # Líneas verticales
  geom_point(size = 2.5,
             shape = 21,
             fill = "purple") + # Puntos de color en el extremo de las líneas
  labs(x = "Lag",
       y = "ACF",
       title = "Gráfico de Autocorrelación para los residuos del modelo AR(1)") +
  theme_bw() +
  theme(axis.text.y = element_text(size = 8),
        # axis.ticks.y = element_blank(),
        axis.title.y = element_text(size = 8),
        plot.title = element_text(size = 10,
                                  face = "bold", # Titulo en negrita
                                  color = "black",
                                  hjust = 0.5),
        axis.title.x = element_text(size = 8),
        axis.text.x = element_text(size = 8))

pacf = pacf_data %>%
  ggplot(aes(x = Lag, y = PACF)) +
  geom_hline(yintercept = 0,
             linetype = "dashed") + 
  geom_hline(yintercept = 1.96/sqrt(n),
             linetype = "dashed",
             col = "blue") + 
  geom_hline(yintercept = -1.96/sqrt(n),
             linetype = "dashed",
             col = "blue") + 
  geom_segment(aes(xend = Lag,
                   yend = 0),
               color = "purple",
               size = 1) + # Líneas verticales
  geom_point(size = 2.5,
             shape = 21,
             fill = "purple") + # Puntos de color en el extremo de las líneas
  labs(x = "Lag",
       y = "PACF",
       title = "Gráfico de Autocorrelación Parcial para los residuos del modelo AR(1)") +
  theme_bw() +
  theme(axis.text.y = element_text(size = 8),
        # axis.ticks.y = element_blank(),
        axis.title.y = element_text(size = 8),
        plot.title = element_text(size = 10,
                                  face = "bold", # Titulo en negrita
                                  color = "black",
                                  hjust = 0.5),
        axis.title.x = element_text(size = 8),
        axis.text.x = element_text(size = 8))+
  scale_y_continuous(limits = c(-0.8,0.8))

(acf | pacf)
```

- Los residuos no son normales: A pesar de que el modelo creado es bueno en muchos sentido, no logra normalizar los residuos, lo que se comprueba sencillamente con test de Kolmogorov-Smirnov, pues el valor-p asociado a dicho estadístico es extremadamente pequeño lo que nos hace rechazar la normalidad en los residuos.

# Predicciones de los modelos:

Ahora que se tiene ambos modelos, una forma de poder determinar su funcionamiento es probandolos, para ello se usarán datos de testeo correspondiente a los meses de enero a septiembre del 2023, los cuales se pueden visualizar en la Tabla 2:

```{r echo=FALSE}
predicciones_validacion <- forecast(fit, newdata = t_test,h = 11)
```


\begin{table}[ht]
\centering
\begin{tabular}{| c | c | c | c |}
\toprule
Mes & Valor Real & Predicción Modelo 1 & Predicción Modelo AR(1) \\
\hline
Enero & 0.37 & 0.35 & 0.29  \\
\hline
Febrero  & 0.57 & 0.33 & 0.31 \\
\hline
Marzo & 0.56 & 0.39 & 0.43  \\
\hline
Abril & 0.66 & 0.60 & 0.73  \\
\hline
Mayo & 1.17 & 0.94 & 1.91  \\
\hline
Junio & 1.53 & 1.44 & 1.47  \\
\hline
Julio & 1.47 & 1.41 & 1.40  \\
\hline
Agosto & 0.98 & 0.90 & 0.88  \\
\hline
Septiembre & 0.73 & 0.57 & 0.56  \\
\bottomrule
\end{tabular}
\caption{Comparación de predicciones}
\label{tab:cuartiles}
\end{table}

A simple vista de la Tabla 2, es claro observar, que hay valores que si se estiman bastante bien como el mes de abril o agosto, y otros que fallan rotundamente como mayo. Dado que de esta forma es difícil determinar cuál es mejor se usarán algunos valores para medir la calidad del ajuste como el MAPE o MSE, los cuales pueden ser observados en la Tabla 3:

\begin{table}[ht]
\centering
\begin{tabular}{| c | c | c | c | c | c |}
\hline
 & RMSE & MAE & MAPE & R2adj \\
\hline
Regresión Lineal & 0.15 & 0.12 & 16.35 & 0.90 \\
\hline
Modelo AR(1) & 0.24 & 0.14 & 17.27 & 0.70 \\
\bottomrule
\end{tabular}
\caption{Medidas de calidad de ajuste}
\label{tab:cuartiles}
\end{table}

Argumentar que volaita es cada uno y pq es mejor el auto.arima pero no se como sacar los valores del modelo 1

## Conclusión y Discusión

Explicar por alguna razón pq el auto.arima es mejor en general q como van subiendo año a añlo las volaitas y no se alguna otra cosa que se nos ocurra para terminar esto yuju

